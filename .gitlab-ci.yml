# File: .gitlab-ci.yml
# Massage-Bot CI/CD Pipeline
# ==========================

# Control which types of pipelines can run
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == "master"

image: docker:latest

services:
  - docker:dind

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

stages:
  - test
  - build
  - deploy

# =====================
# STAGE 1: TESTS
# =====================
test_template: &test_template
  stage: test
  image: golang:1.21
  before_script:
    - go version
  script:
    - go mod download
    - go vet ./...
    - go test -v ./...
  artifacts:
    reports:
      junit: report.xml
    paths:
      - coverage.txt
  coverage: '/coverage: (\d+\.\d+%)/'

unit_tests:
  <<: *test_template
  only:
    - master

# =====================
# STAGE 2: BUILD & PUSH
# =====================
build_docker:
  stage: build
  script:
    - echo "ğŸ”¨ Building Docker image..."
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    - echo "ğŸ” Logging into GitLab Container Registry..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - echo "ğŸš€ Pushing image to registry..."
    - docker push $CI_REGISTRY_IMAGE:latest
    - echo "âœ… Image pushed $CI_REGISTRY_IMAGE:latest"
  only:
    - master
  # Cache Docker layers for faster builds
  cache:
    key: docker-cache
    paths:
      - /cache/.docker

# =====================
# STAGE 3: DEPLOY
# =====================
deploy_staging:
  stage: deploy
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  before_script:
    - echo "ğŸ“ Setting up Kubernetes configuration..."
    - mkdir -p ~/.kube
    - echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
    - echo "ğŸ” Creating image pull secret..."
    - kubectl create secret docker-registry gitlab-registry \
      --docker-server=registry.gitlab.com \
      --docker-username=$CI_REGISTRY_USER \
      --docker-password=$CI_REGISTRY_PASSWORD \
      --docker-email="gitlab-ci@example.com" \
      --dry-run=client -o yaml | kubectl apply -f -
    - echo "âœ… Kubernetes setup complete"
  script:
    - echo "ğŸš€ Deploying massage-bot to Kubernetes..."
    - kubectl apply -f k8s/
    - echo "â³ Waiting for deployment rollout (max 2 minutes)..."
    - timeout 120 kubectl rollout status deployment/massage-bot
    - echo "âœ… Deployment successful!"
    - echo ""
    - echo "ğŸ“Š FINAL DEPLOYMENT STATUS:"
    - echo "============================"
    - kubectl get deployments -l app=massage-bot
    - echo ""
    - kubectl get pods -l app=massage-bot -o wide
    - echo ""
    - kubectl get services -l app=massage-bot
    - echo ""
    - echo "ğŸ‰ Massage-Bot is now running in Kubernetes!"
    - echo "ğŸ¤– Telegram @vera_massage_bot"
    - echo "ğŸ¥ Health http://<pod-ip>:8080/health"
  only:
    - master
  when: manual # Manual trigger since shared runners can't reach local minikube
  timeout: 10 minutes

deploy_home_server:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - ssh kirill@$HOME_SERVER_IP "cd /opt/vera-bot && bash scripts/deploy_home_server.sh"
  only:
    - master

stages:
  - test
  - quality
  - security
  - build
  - deploy

variables:
  GO_VERSION: "1.21"
  DOCKER_IMAGE: "registry.gitlab.com/kfilin/massage-bot"
  DOCKER_TAG: "$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA"

cache:
  paths:
    - .cache/go-build
    - go/pkg/mod/
  key: "$CI_COMMIT_REF_SLUG"

before_script:
  - export GO111MODULE=on

# === TESTING ===
unit_tests:
  stage: test
  image: golang:$GO_VERSION
  script:
    - echo "üß™ Running tests for Massage-Bot..."
    - go mod download
    - go vet ./...
    - go test -v -race ./...
  artifacts:
    reports:
      junit: report.xml
  tags:
    - docker

integration_tests:
  stage: test
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - apk add --no-cache curl
  script:
    - docker build -t $DOCKER_IMAGE:test-$CI_PIPELINE_ID .
    - |
      docker run -d --name massage-bot-test \
        -e TELEGRAM_BOT_TOKEN="test-token" \
        -e ADMIN_USER_ID="304528450" \
        -p 8080:8080 \
        $DOCKER_IMAGE:test-$CI_PIPELINE_ID
    - sleep 10
    - |
      response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health || echo "curl_failed")
      if [ "$response" = "200" ]; then
        echo "‚úÖ Health check passed"
      else
        echo "‚ùå Health check failed: $response"
        docker logs massage-bot-test
        exit 1
      fi
    - docker stop massage-bot-test
    - docker rm massage-bot-test
  only:
    - main
    - develop
  tags:
    - docker

# === QUALITY ===
code_quality:
  stage: quality
  image: golang:$GO_VERSION
  script:
    - go mod download
    - test -z $(gofmt -l .)
    - go vet ./...
    - echo "‚úÖ Code quality checks passed"
  tags:
    - docker

# === SECURITY ===
security_scan:
  stage: security
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - docker build -t $DOCKER_IMAGE:security-scan .
    - trivy image --severity HIGH,CRITICAL $DOCKER_IMAGE:security-scan
  only:
    - main
    - develop
  tags:
    - docker

# === BUILD ===
build_docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - |
      docker build \
        -t $DOCKER_IMAGE:$DOCKER_TAG \
        -t $DOCKER_IMAGE:latest \
        .
    - docker push $DOCKER_IMAGE:$DOCKER_TAG
    - docker push $DOCKER_IMAGE:latest
    - echo "‚úÖ Image pushed: $DOCKER_IMAGE:$DOCKER_TAG"
  only:
    - main
    - develop
    - tags
  tags:
    - docker

# === DEPLOY ===
deploy_staging:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - |
      echo "üöÄ Deploying Massage-Bot to Kubernetes staging..."
      kubectl config use-context staging-cluster
      kubectl apply -f k8s/
      kubectl rollout status deployment/massage-bot --timeout=300s
      echo "‚úÖ Massage-Bot staging deployment completed"
  environment:
    name: staging
  only:
    - master  # ‚úÖ CORRECTED: master branch
  when: manual

deploy_production:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - |
      echo "üéØ Deploying Massage-Bot to Kubernetes PRODUCTION..."
      kubectl config use-context production-cluster
      kubectl apply -f k8s/
      kubectl rollout status deployment/massage-bot --timeout=300s
      echo "‚úÖ Massage-Bot production deployment completed"
  environment:
    name: production
  only:
    - master  # ‚úÖ CORRECTED: master branch
  when: manual

workflow:
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
